{"version":3,"file":"index-f3d7f872.js","sources":["../../node_modules/@dfinity/agent/lib/esm/canisterStatus/index.js"],"sourcesContent":["/** @module CanisterStatus */\nimport { lebDecode, PipeArrayBuffer } from '@dfinity/candid';\nimport { Principal } from '@dfinity/principal';\nimport { AgentError } from '../errors';\nimport { Certificate } from '../certificate';\nimport { toHex } from '../utils/buffer';\nimport * as Cbor from '../cbor';\n/**\n *\n * @param {CanisterStatusOptions} options {@link CanisterStatusOptions}\n * @param {CanisterStatusOptions['canisterId']} options.canisterId {@link Principal}\n * @param {CanisterStatusOptions['agent']} options.agent {@link HttpAgent} optional authenticated agent to use to make the canister request. Useful for accessing private metadata under icp:private\n * @param {CanisterStatusOptions['paths']} options.paths {@link Path[]}\n * @returns {Status} object populated with data from the requested paths\n * @example\n * const status = await canisterStatus({\n *   paths: ['controllers', 'candid'],\n *   ...options\n * });\n *\n * const controllers = status.get('controllers');\n */\nexport const request = async (options) => {\n    const { canisterId, agent, paths } = options;\n    const uniquePaths = [...new Set(paths)];\n    // Map path options to their correct formats\n    const encodedPaths = uniquePaths.map(path => {\n        return encodePath(path, canisterId);\n    });\n    const status = new Map();\n    const promises = uniquePaths.map((path, index) => {\n        return (async () => {\n            var _a;\n            try {\n                const response = await agent.readState(canisterId, {\n                    paths: [encodedPaths[index]],\n                });\n                const cert = await Certificate.create({\n                    certificate: response.certificate,\n                    rootKey: agent.rootKey,\n                    canisterId: canisterId,\n                });\n                const data = cert.lookup(encodePath(uniquePaths[index], canisterId));\n                if (!data) {\n                    // Typically, the cert lookup will throw\n                    console.warn(`Expected to find result for path ${path}, but instead found nothing.`);\n                    if (typeof path === 'string') {\n                        status.set(path, null);\n                    }\n                    else {\n                        status.set(path.key, null);\n                    }\n                }\n                else {\n                    switch (path) {\n                        case 'time': {\n                            status.set(path, decodeTime(data));\n                            break;\n                        }\n                        case 'controllers': {\n                            status.set(path, decodeControllers(data));\n                            break;\n                        }\n                        case 'module_hash': {\n                            status.set(path, decodeHex(data));\n                            break;\n                        }\n                        case 'candid': {\n                            status.set(path, new TextDecoder().decode(data));\n                            break;\n                        }\n                        default: {\n                            // Check for CustomPath signature\n                            if (typeof path !== 'string' && 'key' in path && 'path' in path) {\n                                switch (path.decodeStrategy) {\n                                    case 'raw':\n                                        status.set(path.key, data);\n                                        break;\n                                    case 'leb128': {\n                                        status.set(path.key, decodeLeb128(data));\n                                        break;\n                                    }\n                                    case 'cbor': {\n                                        status.set(path.key, decodeCbor(data));\n                                        break;\n                                    }\n                                    case 'hex': {\n                                        status.set(path.key, decodeHex(data));\n                                        break;\n                                    }\n                                    case 'utf-8': {\n                                        status.set(path.key, decodeUtf8(data));\n                                    }\n                                }\n                            }\n                        }\n                    }\n                }\n            }\n            catch (error) {\n                // Break on signature verification errors\n                if ((_a = error === null || error === void 0 ? void 0 : error.message) === null || _a === void 0 ? void 0 : _a.includes('Invalid certificate')) {\n                    throw new AgentError(error.message);\n                }\n                if (typeof path !== 'string' && 'key' in path && 'path' in path) {\n                    status.set(path.key, null);\n                }\n                else {\n                    status.set(path, null);\n                }\n                console.group();\n                console.warn(`Expected to find result for path ${path}, but instead found nothing.`);\n                console.warn(error);\n                console.groupEnd();\n            }\n        })();\n    });\n    // Fetch all values separately, as each option can fail\n    await Promise.all(promises);\n    return status;\n};\nexport const encodePath = (path, canisterId) => {\n    const encoder = new TextEncoder();\n    const encode = (arg) => {\n        return new DataView(encoder.encode(arg).buffer).buffer;\n    };\n    const canisterBuffer = new DataView(canisterId.toUint8Array().buffer).buffer;\n    switch (path) {\n        case 'time':\n            return [encode('time')];\n        case 'controllers':\n            return [encode('canister'), canisterBuffer, encode('controllers')];\n        case 'module_hash':\n            return [encode('canister'), canisterBuffer, encode('module_hash')];\n        case 'subnet':\n            return [encode('subnet')];\n        case 'candid':\n            return [encode('canister'), canisterBuffer, encode('metadata'), encode('candid:service')];\n        default: {\n            // Check for CustomPath signature\n            if ('key' in path && 'path' in path) {\n                // For simplified metadata queries\n                if (typeof path['path'] === 'string' || path['path'] instanceof ArrayBuffer) {\n                    const metaPath = path.path;\n                    const encoded = typeof metaPath === 'string' ? encode(metaPath) : metaPath;\n                    return [encode('canister'), canisterBuffer, encode('metadata'), encoded];\n                    // For non-metadata, return the provided custompath\n                }\n                else {\n                    return path['path'];\n                }\n            }\n        }\n    }\n    throw new Error(`An unexpeected error was encountered while encoding your path for canister status. Please ensure that your path, ${path} was formatted correctly.`);\n};\nconst decodeHex = (buf) => {\n    return toHex(buf);\n};\nconst decodeLeb128 = (buf) => {\n    return lebDecode(new PipeArrayBuffer(buf));\n};\nconst decodeCbor = (buf) => {\n    return Cbor.decode(buf);\n};\nconst decodeUtf8 = (buf) => {\n    return new TextDecoder().decode(buf);\n};\n// time is a LEB128-encoded Nat\nconst decodeTime = (buf) => {\n    const decoded = decodeLeb128(buf);\n    return new Date(Number(decoded / BigInt(1000000)));\n};\n// Controllers are CBOR-encoded buffers, starting with a Tag we don't need\nconst decodeControllers = (buf) => {\n    // eslint-disable-next-line @typescript-eslint/no-unused-vars\n    const [tag, ...controllersRaw] = decodeCbor(buf);\n    return controllersRaw.map((buf) => {\n        return Principal.fromUint8Array(new Uint8Array(buf));\n    });\n};\n//# sourceMappingURL=index.js.map"],"names":["request","options","canisterId","agent","paths","uniquePaths","encodedPaths","path","encodePath","status","promises","index","_a","response","data","Certificate","decodeTime","decodeControllers","decodeHex","decodeLeb128","decodeCbor","decodeUtf8","error","AgentError","encoder","encode","arg","canisterBuffer","metaPath","encoded","buf","toHex","lebDecode","PipeArrayBuffer","Cbor.decode","decoded","tag","controllersRaw","Principal"],"mappings":"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","x_google_ignoreList":[0]}